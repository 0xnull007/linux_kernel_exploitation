A use-after-free flaw was found in the netfilter subsystem of the Linux kernel. If the catchall element is garbage-collected when the pipapo set is removed, the element can be deactivated twice. This can cause a use-after-free issue on an NFT_CHAIN object or NFT_OBJECT object, allowing a local unprivileged user with CAP_NET_ADMIN capability to escalate their privileges on the system.

You can read its details at https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2024-0193_lts

This gadget was not found in kernel 6.1.67 despite of all the required configs.
`0xffffffff81f5f869 : push rbx ; and byte ptr [rbx + 0x41], bl ; pop rsp ; pop rbp ; jmp 0xffffffff820033c0 ----> Not Found`

But I found these 4 gadgets, when executed in this order will work as above gadget.
`0xffffffff81a11001 : xor ecx, ecx ; mov rax, r9 ; jmp 0xffffffff820033c0`
`0xffffffff8109c2b4 : xor edx, edx ; mov rax, r10 ; jmp 0xffffffff820033c0`
`0xffffffff81368ac7 : push rbx ; pop rsp ; cmp rcx, rdx ; jb 0xffffffff81368aaf ; pop rbx ; jmp 0xffffffff820033c0`
`0xffffffff8111128f : push rbx ; pop rbp ; pop r12 ; jmp 0xffffffff820033c0`

But when I executed the exploit, I found out that our ROP isn't being executed. The actual error was in triggering part of the exploit. So, to debug it, I learned about netfilter specifically nf_tables and nft(utility to manage nftables). But unfortunately I couldn't complete this task.